---
layout: post
title: 리액트 성능 최적화
category: React
permalink: /react/:year/:month/:day/:title/
tags: [React]
comments: true
---

---

## 리액트 성능 최적화

---

웹 성능 결정 요소

* 로딩 성능 : 리소스를 불러오는 성능

* 렌더링 성능 : 불러온 리소스를 화면에 그려주는 성능

---

#### 1. 브라우저의 렌더링 원리

1. HTML => DOM, CSS => CSSOM 가공하여 tree 구조로 세팅

2. tree를 조합하여 Render Tree 생성

3. Layout 연산 (width, height 등)

4. Layout 위에 Paint (color, shadow 등)

5. Composite 단계에서 각 레이어를 합성

* 이 전체 과정을 Critical Rendering Path 혹은 Pixel Pipeline이라 한다
* width, height 등 크기 변경 시, 1~5 전 과정을 실행 => **Reflow**
* color, background-color 등 색깔 변경 시, 3(Layout 연산) 스킵 => **Repaint** 
* **Reflow**
  * position, width, height, left, top, right, bottom, margin, padding, border, display, float, font-family, font-size, font-weight, line-height, overflow, min-height, text-align, vertical-align...
* **Repaint**
  * background, background-\*, border-radius, border-style, box-shadow, color, line-style, outline, outline-\*, text-decoration...

#### 2. Performance 패널을 이용한 분석

* 개발자도구의 Performance 탭에서 분석이 가능
* Frame Chart를 보며 시간이 오래 걸리는 컴포넌트, 함수를 리팩토링

#### 3. Lighthouse 패널을 이용한 분석

* 개발자도구의 Lighthouse로 퍼포먼스 점수 분석이 가능
* Opportunities나 Diagnostics에 적힌 내용들을 수정하여 최적화

#### 4. Network 패널을 이용한 분석

* 개발자도구의 Network 패널을 이용해 network 통신 분석이 가능

#### 5. Coverage 패널을 이용한 분석

#### 6. webpack-bundle-analyzer를 이용한 분석

* webpack-bundle-analyzer 패키지 설치 후 사용
* CRA는 cra-bundle-analyzer 사용
* npm 패키지가 불필요한 페이지에서 사용될 경우 분리시킬 필요가 있다
* code splitting 적용

#### 7. 텍스트 압축

* 로딩 성능 최적화
* 서버에서 받는 리소스를 압축해서 받고 풀어서 클라에게 전송
* Response Header에 Content-Encoding 항목이 있으면 압축된 것
* 리소스를 제공하는 서버나 Router 서버에서 Compression을 적용
* 무분별하게 압축하면 오히려 성능 저하가 올 수도 있음
* 기본적으로 2KB 이상일 경우 compression 실행

#### 8. 이미지/동영상 사이즈 최적화

* 로딩 성능 최적화
* 애초에 이미지 사이즈를 줄이거나 코드를 통해 이미지를 줄여라

#### 9. 이미지 CDN을 통한 최적화

* 로딩 성능 최적화

* 이미지를 불러올 때, CDN으로 호출하여 직접 구현하거나 imgix 등 툴을 이용하여
  필요한 크기로 줄여서 불러옴

#### 10. 캐시 최적화

#### 11. 이미지 preload

* 로딩 성능 최적화
* javascript의 `Image Object`를 이용하여 preload를 구현할 수 있다

```react
import React, { useEffect } from 'react';

function App() {
    useEffect(() => {
        const img = new Image();
        img.src = 'https://경로';
    }, []);
    
    retrun (/* ... */)
};
```

* `img.src`가 실행되는 순간 네트워크 통신을 하기 때문에 캐싱이 필요하다
* 이미지의 **cache-control** 설정은 따로 찾아보도록..
* 모든 이미지를 캐싱하여 보관하면 오히려 다른 성능에 영향일 미칠 수 있으므로,
  제일 중요하고 큼지막한 이미지를 위주로 선정하자

#### 12. 컴포넌트 preload

* 로딩 성능 최적화
* 사용자의 상호작용이 필요한 컴포넌트를 미리 load하여 가지고 있는다
* 하지만 그 시점이 애매하다
* 버튼의 경우, 버튼을 누를지 안누를지 모르기 때문
  * 버튼 위에 마우스를 올렸을 때 적용 가능
  * 최초 페이지 로드 후 모든 컴포넌트의 마운트 후에 적용 가능

* 팩토리 패턴을 이용한 preload 방법

```react
import React, { useEffect, Suspense, lazy } from 'react';

function lazyWithPreload(importFunction) {
    const Component = lazy(importFunction);
    Component.preload = importFunction;
    return Component;
};

const LazyModal = lazyWithPreload(() => import('./components/Modal'));

function App() {
    
    useEffect(() => {
        LazyModal.preload();
    }, []);
    
    return (
    	<Suspsnse fallback={null}>
        	<LazyModal />
        </Suspsnse>
    );
};
```

* 컴포넌트의 마운트가 모두 완료된 후, lazy를 먹인 import를 실행하는 방법 

#### 13. Lazy Load

* 로딩 성능 최적화
* React의 suspense, lazy 사용
* Next.js Dynamic import 사용
* 최초 로딩 속도는 향상시킬 수 있으나 그 후에는 성능이 오히려 떨어질 수도 있다
* 따라서, preload를 적용하여 이를 보완한다

#### 14. Code Splitting

* 로딩 성능 최적화
* 불필요, 중복되는 코드가 없이 적절한 사이즈의 코드가 적절한 타이밍에 로드되도록

#### 15. 이미지 Lazy Load

* 로딩 성능 최적화

* Intersection Observer를 사용하여 이미지 지연로딩 처리가 가능하다
* 스크롤 이벤트는 매 스크롤 마다 함수가 실행되어 성능 최적화에 맞지 않다

```react
import React, { useEffect, useRef } from 'react';

function App() {
    const ref = useRef(null);
    
    useEffect(() => {
  		const opts = {};
        const cb = (entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.src = entry.target.dataset.src;
                    observer.unobserve(entry.target);
                }
            });
        };
        const observer = new IntersectionObserver(cb, opts);
        
        observer.observe(ref.current);
    }, []);
    
    return (
    	<div>
        	<img data-src={"https://경로"} ref={ref} />
        </div>
    )
};
```

* 스크롤을 내리다 이미지가 observe되는 순간 data 속성으로 박아놓은 경로를 src에 넣어준다
* 나중에 로드해도 되는 이미지를 지연로딩 함으로서, 초기 로딩 속도를 개선할 수 있음

#### 16. 병목 코드 제거

* 렌더링 성능 최적화

#### 17. repaint, reflow 줄이기

* 렌더링 성능 최적화
* GPU의 도움으로 repaint, reflow를 줄일 수 있다
* transform, opacity 등 GPU가 관여할 수 있는 속성을 사용하여 Layout, paint 과정을 생략할 수 있다

#### 18. 불필요한 CSS 제거 방법

#### 19. Layout Shift 피하는 방법

#### 20. useSelector 렌더링 문제 해결법

#### 21. Redux Reselect를 통한 렌더링 최적화

#### 22. memoization을 이용한 최적화

#### 23. 폰트 최적화

<br>

---

## 참고 자료

---

프론트엔드 개발자를 위한, 실전 웹 성능 최적화(feat.React)
