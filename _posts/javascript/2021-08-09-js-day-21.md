---
layout: post
title: RxJS Operator (계속 업데이트)
category: Javascript
permalink: /javascript/:year/:month/:day/:title/
tags: [Javascript]
comments: true
---

---

## [RxJS] Operator (계속 업데이트)

---

### 1. Operator

연산자는 함수이다. 연산자에는 2종류가 있다.

- **파이프형 연산자** : pipe(operator()) 구문을 사용해서 input에 대한 같은 output만을 반환하는 순수연산을 한다. 따라서, 파이프형 연산자는 순수함수이고 Observable 객체를 받아 다른 Observable을 반환한다.

  **pipe()** : 파이프 연산자는 RxJS 5.5 이전에 사용되던 chaining을 가독성 좋게 사용할 수 있게 해준다.

  ```javascript
  // Before RxJS 5.5
  Observable.operator1().operator2().operator3().subscribe(...);
                    
  // Since RxJS 5.5
  Observable.pipe(
  	operator1(),
      operator2(),
      operator3()
  ).subscribe(...);
  ```

  <br>

- **생성 연산자** : 새로운 Observable 객체를 생성하기 위해 단독 함수로서 호출될 수 있다. 

<br>

### 2. Higher-order Observables (고차 Observables)

Observable은 보편적으로 string, number 같은 보통의 값을 내보내지만, observable을 다루는 observable을 고차 Observable이라고 한다.

고차 Observable은 일반적으로 평탄화해서 사용하는데 고차 Observable을 하나의 보통 Observable로 바꿔서 사용한다.

concatAll(), mergeAll(), switchAll(), exhaust(), concatMap(), mergeMap(), switchMap(), exhaustMap() 등 사용.

<br>

### 3. Marble Diagram (마블 다이어그램)

Observable의 연산자를 설명할 때 시간의 흐름에 따라 어떻게 작동하는지 그림을 통해 시각적으로 제공한다.

>  Marble Diagram : https://rxmarbles.com/

<br>

### 4. Custom Operator

pipe() 함수로 새로운 연산자를 만들 수 있다. 흔히 사용되는 연산자들의 시퀀스를 하나로 묶을 수 있다.

```javascript
import { pipe } from 'rxjs';
import { filter, map } from 'rxjs/operators';

function discardOddDoubleEven() {
    return pipe(
    	filter(v => !(v % 2)),
        map(v => v + v),
    );
}
// 홀수를 버리고 짝수를 2배하는 Custom Operator
```

<u>pipe() 함수는 Observable의 pipe() 메소드와 유사하지만 같지 않다.</u>

<br>

### 5. 자주 사용되는 연산자 정리

#### Creation Operators

**of()** : 나열된 인자를 순서대로 next하는 Observable 반환

```javascript
import { of } from 'rxjs';

of(1,2,3)
 .subscribe(
   next => console.log('next: ', next),
   err => console.log('err: ', err),
   () => console.log('complete')
 );
// next: 1, next: 2, next: 3, complete

// 배열을 전달하면 배열이 통으로 나옴
of([1,2,3])
 .subscribe(
   next => console.log('next: ', next),
   err => console.log('err: ', err),
   () => console.log('complete')
 );
// next: [1,2,3], complete
```

<bt>

**from()** : array, observable, Promise, string, array-like, iterable 등을 Observable로 반환

```javascript
import { from } from 'rxjs';

const arr = [1,2,3];
const result = from(arr);
result.subscribe(x => console.log(x));
// 1, 2, 3
```

<br>

**fromEvent()** : 브라우저에서 발생하는 Event를 Observable로 반환

```javascript
import { fromEvent } from 'rxjs';

const clicks = fromEvent(document, 'click');
clicks.subscribe(x => console.log(x));
// MouseEvent Object
```

<br>

**defer()** : 팩토리 함수로 Observable 생성 후 구독 시점에 팩토리 함수를 호출해 만들어둔 Observable 반환받아 구독한다. from은 Promise 생성 후 바로 동작시키지만 defer는 Observable을 subscribe하는 시점에 Promise를 생성할 수 있어서 동작 시점을 조절할 수 있다.

```javascript
import { defer, fromEvent, interval } from 'rxjs';

const clickOrInterval = defer(() => {
    return Math.random() > 0.5
     ? fromEvent(document, 'click')
     : interval(1000)
});
clickOrInterval.subscribe(x => console.log(x));

// 랜덤 숫자가 0.5보다 크면 클릭 이벤트를 대기한다.
// 랜덤 숫자가 0.5보다 작으면 1초마다 방출한다.
```

<br>

**range()** : 범위 내 숫자들을 갖는 Observable 생성

```javascript
import { range } from 'rxjs';

const numbers = range(1, 10);
numbers.subscribe(x => console.log(x));
// 1부터 10까지 출력
```

<br>

**interval()** : setInterval()과 유사하며 일정 간격마다 값을 발행하는데 0부터 순차적으로 증가, 명시적으로 구독해제 하지 않으면 무한하게 값을 발행하니 주의할 것.

```javascript
import { interval } from 'rxjs';

const intervalObservable = interval(1000).subscribe(
  v => console.log('next: ', v),
  err => console.log('err: ', err),
  () => console.log('complete')
);

setTimeout(() => {
    intervalObservable.unsubscribe();
}, 3000);

// next: 1, next: 2, next: 3, complete
```

<br>

**timer()** : setTimeout()과 유사하며 특정 시간 이후 값을 발행한다.

```javascript
import { timer } from 'rxjs';

const numbers = timer(3000, 1000); // 3초 후에 시작하며 1초마다 발행
numbers.subscribe(x => console.log(x));

setTimeout(() => {
    numbers.unsubscribe();
}, 6000);

// 0, 1, 2
```

<br>

**empty(), never(), throwError()** : empty()는 Observable complete 상태를 전달하는 Observable 생성, never()는 어떤값도 발행하지 않는 Observable, throwError()는 호출 즉시 에러를 발생시킨다. empty()와 never()는 RxJS 6 이후 deprecated되었으며 상수로 변경되었다.

```javascript
import { EMPTY } from 'rxjs';

EMPTY.subscribe(
  () => console.log('next'),
  (err) => console.log('err'),
  () => console.log('complete') 
);
// complete

import { NEVER } from 'rxjs';

NEVER.subscribe(
  () => console.log('next'),
  (err) => console.log('err'),
  () => console.log('complete') 
);
// 아무것도 출력되지 않음

import { throwError } from 'rxjs';

throwError('err!').subscribe(
  () => console.log('next'),
  (err) => console.log('err: ', err),
  () => console.log('complete') 
);
// err: err!
```

<br>

**map()** : array method의 map과 유사하며 Observable을 다른 Observable로 변환하는데 사용된다.

```javascript
const observable = of(1,2,3,4,5);

const subscription = observable.pipe(
	map(val => val * val)
).subscribe(val => console.log(val));
// 1, 4, 9, 16, 25
```

<br>

**filter()** : array method의 filter와 유사하며 Observable의 필터링에 사용된다

```javascript
const observable = of(1,2,3,4,5);

const subscription = observable.pipe(
	filter(val => val % 2 === 0)
).subscribe(val => console.log(val));
// 2, 4
```

<br>

<br>

---

## 참고 자료

---

[ReactiveX 공식문서](http://reactivex.io/)

[RxJS 공식문서](https://rxjs.dev/)

[[Javascript] RxJS - Operators](https://steadev.tistory.com/59)
