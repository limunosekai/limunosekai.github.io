---
layout: post
title: SCSS Pre-processor 사용법
category: HTML/CSS
permalink: /html/:year/:month/:day/:title/
tags: [HTML/CSS]
comments: true
---

---

## SCSS Pre-processor 사용법

---

1. **SCSS Pre-processor**

   * CSS의 확장 기능으로 전처리기라고 부른다
   * 중첩, 조건문, 반복문, 연산 등 CSS에서 불가능했던 기능들을 작성할 수 있다
   * 웹은 CSS만 인식할 수 있기 때문에 컴파일 단계가 필요하다
   * CSS 확장 언어에는 SCSS (Sass), Less, Stylus 등이 있다
   * SCSS는 Sass 3버전에서 등장했으며 Sass의 모든 기능을 지원하고 CSS 구문과 완전히 호화되는 CSS의 상위집합이다

   <br>

2. **Compile**

   * SassMeister :  일종의 play-ground이다 [링크](https://www.sassmeister.com/)

   * node-sass :  Node.js의 컴파일러인 LibSass에 바인딩한 패키지로 SCSS 컴파일이 가능하다

     ```javascript
     // npm install node-sass
     
     // node-sass [옵션] <입력파일경로> [출력파일경로]
     //ex) node-sass --watch scss/main.scss dist/style.css
     ```

   * Gulp : 빌드 자동화 도구인 Gulp에서 gulp-sass 컴파일러로 node-sass를 사용하도록 설정할 수 있다

     ```javascript
     // npm install --save-dev gulp gulp-sass
     
     // gulpfile.js
     const gulp = require('gulp')
     const sass = require('gulp-sass')
     
     // 일반 컴파일
     gulp.task('sass', function () {
       return gulp.src('./src/scss/*.scss')  // 입력 경로
         .pipe(sass().on('error', sass.logError))
         .pipe(gulp.dest('./dist/css'));  // 출력 경로
     });
     
     // 런타임 중 파일 감시
     gulp.task('sass:watch', function () {
       gulp.watch('./src/scss/*.scss', ['sass']);  // 입력 경로와 파일 변경 감지 시 실행할 Actions(Task Name)
     });
     
     // gulp sass 혹은 gulp sass:watch 명령어로 컴파일
     ```

   * Webpack : sass-loader 사용

     ```javascript
     const MiniCssExtractPlugin = require('mini-css-extract-plugin');
     
     module.exports = {
         //...
         module: {
             rules: [
                 {
                     test: /\.(sass|scss)$/,
                     use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'],
                 }
             ]
         }
     }
     ```

   * Parcel : 웹앱 번들러인 Parcel을 사용한다

     ```javascript
     // npm install -g parcel-bundler
     
     // npm install --save-dev node-sass
     
     // html에서 링크 태그로 scss 파일 연결
     
     // parcel build xxx.html
     
     // 빌드된 파일은 dist/에서 확인, 별도 포트지정 안하면 localhost:1234에서 확인 가능
     ```

   * Live Sass Compiler : VS Code의 플러그인으로 컴파일을 자동으로 해준다

3. **Syntax**

   * 주석 : `// 컴파일되지 않는 주석`, `/* 컴파일되는 주석*/`

   * 데이터 종류: Number, String, Color, Boolean, Null, List, Map
     Map은 `Key: Value` 형태로 `()` 안에 정의해야한다 `ex) (foo: a, bar: b)`

   * Nesting : 중첩 기능으로 상위 선택자의 반복을 피할 수 있다

     ```scss
     .foo {
         .bar {
             li {
                 color: red;
             }
         }
     }
     ```

     `& (ampersand)` 선택자로 상위(부모) 선택자를 참조할 수 있다

     ```scss
     .list {
         li {
             &:last-child {
                 margin-bottom: 10px;
             }
         }
     }
     ```

     엠퍼샌드를 클래스명에 사용할 수도 있다

     ```scss
     .foo {
         &-bar { color: blue; }
         &-baz { color: red; }
     }
     
     // 컴파일 후..
     
     .foo-bar { color: blue; }
     .foo-baz { color: red; }
     ```

     중첩에서 벗어나고 싶으면 `@at-root` 키워드를 사용한다

     특정 변수를 정의하면 변수를 정의한 스코프에서만 적용할 수 있기 때문에 이런 경우에 사용한다

     ```scss
     .foo {
         $w: 20px;
         li {
             width: $w;
         }
         @at-root .bar {
             width: $w;
         }
     }
     
     // 컴파일 후..
     
     .foo li {
         width: 30px;
     }
     .bar {
         width: 20px;
     }
     ```

     `font-size`, `font-weight` 등 동일한 네임스페이스 `font-`를 가진 속성에서도 중첩이 가능하다

     ```scss
     .foo {
         font: {
             size: 10px;
             weight: bold;
             family: sans-serif;
         }
         margin: {
             top: 10px;
             bottom: 20px;
         }
     }
     ```

     <br>

   * Variable

   * import

   * calculation

   * mixin / include

   * function

   * if

   * for / each / while

<br>

---

## 참고 자료

---

[sass doc](https://sass-lang.com/guide)

[Sass(SCSS) 완전 정복!](https://heropy.blog/2018/01/31/sass/)

[]()